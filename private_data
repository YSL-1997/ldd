./mmap/simple.c:                    vma->vm_start, vma->vm_pgoff << PAGE_SHIFT);
./mmap/simple.c:     * vma->vm_pgoff contains the page frame number (physical address right-shifted
./mmap/simple.c:     * So if we perform left-shift on vma->vm_pgoff by PAGE_SHIFT bits,
./mmap/simple.c:    if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff, 
./mmap/simple.c:                        vma->vm_end - vma->vm_start, 
./mmap/simple.c:                        vma->vm_page_prot)){
./mmap/simple.c:     * to store "a pointer to simple_remap_vm_ops" in the "vma->vm_ops" field of 
./mmap/simple.c:    vma->vm_ops = &simple_remap_vm_ops;
./mmap/simple.c:    unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
./mmap/simple.c:        vma->vm_flags |= VM_IO;
./mmap/simple.c:        // vma->vm_flags = vma->vm_flags | VM_IO; bit-wise OR operator
./mmap/simple.c:    vma->vm_flags |= VM_REVERSED;
./mmap/simple.c:     * to store "a pointer to simple_remap_vm_ops" in the "vma->vm_ops" field of 
./mmap/simple.c:    vma->vm_ops = &simple_nopage_vm_ops;
./mmap/simple.c:    unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
./mmap/simple.c:    unsigned long physaddr = adress - vma->vm_start + offset;
./scullp/mmap.c:	struct scullp_dev *dev = vma->vm_private_data;
./scullp/mmap.c:	struct scullp_dev *dev = vma->vm_private_data;
